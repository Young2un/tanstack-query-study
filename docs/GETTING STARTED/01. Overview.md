# Overview

<aside>

**서버 상태를 다루는 라이브러리**

</aside>

**서버상태가 어려운이유 (tanstack-query가 필요한 이유)**

- 제어하거나 소유할 수 없는 위치에 원격으로 유지
  - 서버에 저장되어 있어서 직접 **제어할 수 없음** (예: DB에 저장된 게시글 목록)
  - 서버 상태를 변경하는 API 요청은 가능 (우리가 제어하는 ‘방법’은 있음)
    → 완전한 통제는 불가
- 비동기 API가 필요
  - 서버에서 데이터를 가져오거나 바꾸려면 항상 API 호출이 필요
  - 이걸 직접 관리하려면 복잡한 로딩/에러/성공 상태 처리가 필요
- 공유 소유권을 의미하며 사용자 모르게 다른 사람이 변경가능
  - 내가 바꾸지 않아도, **누군가가 바꿨을 수 있음**
    → 즉, 신선도(=최신 상태)를 보장하기 어려움
- 주의하지 않으면 애플리케이션에서 ‘구시대적’이 될 수 있다?
  - 내가 불러온 서버 데이터가 최신이 아니면
    → 사용자 입장에서 오래된 정보(예: 삭제된 게시글, 이전 가격 등)를 볼 수 있음.
    이걸 방치하면 **신뢰성 떨어지는 앱**이 된다는 얘기

**서버 상태를 다룰 때 생기는 실질적인 문제들 (tanstack-query가 해주는 것들)**

**1. 캐싱 (아마도 제일 까다로운것)**

같은 요청을 반복하지 않도록 데이터를 저장해두는 기능 필요함.

하지만 언제 캐시하고 언제 폐기할지 결정하는 건 매우 어려운 문제임.

**2. 중복 요청 처리**

동일한 데이터를 여러 컴포넌트에서 요청할 경우,

중복된 API 요청이 발생하지 않도록 하나의 요청으로 묶어야 함.

**3. 백그라운드 업데이트**

사용자가 앱을 보는 동안에도 서버 데이터는 바뀔 수 있음.

이를 감지하고 백그라운드에서 자동으로 최신 데이터를 가져오는 기능이 필요함.

**4. 데이터 신선도 판단**

클라이언트가 가지고 있는 데이터가 여전히 최신인지 판단할 기준이 필요함.

(예: 마지막 요청 시각, 포커스 전환 시 재요청 등)

**5. 빠른 UI 반영 (낙관적 업데이트)**

사용자의 입력에 대해 서버 응답을 기다리지 않고 먼저 화면을 업데이트해주는 처리 필요함.

**6. 페이징 / 지연 로딩**

많은 양의 데이터를 한 번에 불러오는 것은 비효율적임.

필요한 만큼만 나눠서 불러오는 페이징, 무한 스크롤 등의 처리 필요함.

**7. 메모리 및 가비지 컬렉션 관리**

더 이상 사용하지 않는 서버 데이터를 캐시에서 자동으로 제거해야 함.

이를 통해 메모리 낭비를 방지함.

**8. 구조적 공유(Structural Sharing)**

이전 쿼리 결과와 일부만 다른 경우, 변경된 부분만 반영하고

나머지는 기존 데이터를 재사용함으로써 메모리 효율과 렌더링 성능을 높일 수 있음.
